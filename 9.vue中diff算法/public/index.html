<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
  <div id="app">
      <my-component></my-component>
      <my-component></my-component>
      <my-component></my-component>
  </div>
  <script src="/dist/umd/vue.js"></script>
  <script>

      // 遇到了自定义组件,先找Vue实例上有没有,没有再找Vue全局上,需要更改component的合并策略
      //       即重名用实例自己的,实例没有用全局
      //     在render -> vdom的过程中，createElement创建的vnode只能表示现存的标签
      //       如果想要表示自定义组件，需要用createComponent方法 


      
      // 内部会调用 Vue.extend 返回一个组件的构造函数， 通过new 这个构造函数产生实例
      Vue.component('my-component', {
          template: '<div>hello 你好</div>',
      });
      debugger;
      let vm = new Vue({
          el: '#app',
          data() {
              return {
                  name: 'zf'
              }
          },
          components: {
              'my-component': {
                  template: '<div>hello 不好 </div>'
              }
          }
      });

      // 组件渲染的时候 会调用当前组件对应的构造函数 ，产生一个实例
      // 我们可以new 这个类  每个组件调用都会new一下

      // 每个组件在使用时都会调用Vue.extend方法 创建一个构造函数
      // 实例化子组件时 会将当前选项和用户定义选项合并 mergeOptions
      // 通过创建实例 内部会调用子类的_init() 内部会再创建一个渲染watcher 将渲染后的结果放到 vm.$el上 = 组件的渲染结果


      // 局部组件和全局组件的区别
  </script>


</body>


</html>